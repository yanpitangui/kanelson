@using Microsoft.AspNetCore.SignalR.Client
@using global::Shared.Models
@using System.Collections.Immutable
@using System.Net
@using Kanelson.Hubs
@using Kanelson.Services
@using Microsoft.AspNetCore.SignalR
@inject NavigationManager Navigation
@inject IHttpContextAccessor httpAccessor
@implements IAsyncDisposable
<h3>Player</h3>



<MudList>
    
    @foreach (var user in _connectedUsers)
    {
        <MudListItem>
            <Avatar GithubId="@user.Id"/>  <span>@user.Name</span>
        </MudListItem>
    }
</MudList>

@if (_currentQuestion is not null)
{
    <MudCard>
        <MudCardHeader>
            @_currentQuestion.Name
        </MudCardHeader>
        <MudCardContent>
            <MudList>
                @foreach (var answer in _currentQuestion.Answers)
                {
                    <MudListItem>@answer.Description</MudListItem>
                }
            </MudList>
        </MudCardContent>
    </MudCard>
}

<MudProgressCircular Color="Color.Default" Indeterminate="true" />

@code {

    TemplateQuestion? _currentQuestion;
    [Parameter]
    public string RoomId { get; set; } = null!;
    private HubConnection? hubConnection;
    private ImmutableArray<UserInfo> _connectedUsers = ImmutableArray<UserInfo>.Empty;

    protected override async Task OnParametersSetAsync()
    {
        hubConnection = httpAccessor.GetConnection(Navigation);
        hubConnection.On<HashSet<UserInfo>>("CurrentUsersUpdated", (users) =>
        {
            _connectedUsers = users.ToImmutableArray();
            StateHasChanged();
        });
        
        // não trazer a informação de qual questão é correta aqui
        hubConnection.On<TemplateQuestion>("Started", (question) =>
        {
            _currentQuestion = question;
            StateHasChanged();
        });

        await hubConnection.StartAsync();

        await hubConnection.SendAsync("JoinRoom", RoomId);
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is IAsyncDisposable disposable)
        {
            await disposable.DisposeAsync();
        }
    }

}